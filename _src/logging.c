
#define _GNU_SOURCE
#include <stdarg.h>
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include "am/threads.h"
#include "am/common.h"
#include "am/logging.h"

#define ANSI_RED        "\033[1;31m"
#define ANSI_GREEN      "\033[1;32m"
#define ANSI_YELLOW     "\033[1;33m"
#define ANSI_MAGENTA    "\033[1;35m"
#define ANSI_LIGHT_BLUE "\033[34m"
#define ANSI_RESET      "\033[0m"

static am_mutex g_messages_lock;
static am_tss g_log_structured_depth;
static am_log_writer_fn *g_log_writer_fn = am_log_writer_default;
static void *g_log_writer_userdata = NULL;

static am_once_flag g_initialized = AM_ONCE_FLAG_INITIALIZER;

/* Cleanup the logging library */
static
void cleanup(void)
{
    am_tss_delete(g_log_structured_depth);
    am_mutex_destroy(&g_messages_lock);
}

/* Setup the logging library */
static
void setup(void)
{
    int ret;
    ret = am_tss_create(&g_log_structured_depth, NULL);
    if (ret != AM_THREAD_SUCCESS) {
        abort();
    }

    ret = am_mutex_init(&g_messages_lock, AM_MUTEX_PLAIN);
    if (ret != AM_THREAD_SUCCESS) {
        abort();
    }

    atexit(cleanup);
}

/* abort, leaving a breakpoint if @p breakpoint is true */
static AM_NORETURN
void log_abort(bool breakpoint)
{
    /* TODO: breakpoint */
    (void)breakpoint;
    abort();
}

static AM_ATTR_RETURNS_NON_NULL
const char *log_level_to_string(enum am_log_level_flags log_level)
{
    if (log_level & AM_LOG_LEVEL_CRITICAL) {
        return "Critical";
    } else if (log_level & AM_LOG_LEVEL_ERROR) {
        return "Error";
    } else if (log_level & AM_LOG_LEVEL_WARNING) {
        return "Warning";
    } else if (log_level & AM_LOG_LEVEL_NOTICE) {
        return "Notice";
    } else if (log_level & AM_LOG_LEVEL_INFO) {
        return "Info";
    } else if (log_level & AM_LOG_LEVEL_DEBUG) {
        return "Debug";
    } else {
        return "";
    }
}

static AM_ATTR_RETURNS_NON_NULL
const char *log_level_to_priority(enum am_log_level_flags log_level)
{
    if (log_level & AM_LOG_LEVEL_CRITICAL) {
        return "2";
    } else if (log_level & AM_LOG_LEVEL_ERROR) {
        return "3";
    } else if (log_level & AM_LOG_LEVEL_WARNING) {
        return "4";
    } else if (log_level & AM_LOG_LEVEL_NOTICE) {
        return "5";
    } else if (log_level & AM_LOG_LEVEL_INFO) {
        return "6";
    } else if (log_level & AM_LOG_LEVEL_DEBUG) {
        return "7";
    } else {
        /* Default to AM_LOG_LEVEL_NOTICE */
        return "5";
    }
}

static AM_ATTR_RETURNS_NON_NULL
const char *log_level_to_color(enum am_log_level_flags log_level, bool color)
{
    if (!color) {
        return "";
    }
    if (log_level & AM_LOG_LEVEL_CRITICAL) {
        return ANSI_RED;
    } else if (log_level & AM_LOG_LEVEL_ERROR) {
        return ANSI_MAGENTA;
    } else if (log_level & AM_LOG_LEVEL_WARNING) {
        return ANSI_YELLOW;
    } else if (log_level & AM_LOG_LEVEL_NOTICE) {
        return ANSI_GREEN;
    } else if (log_level & AM_LOG_LEVEL_INFO) {
        return ANSI_GREEN;
    } else if (log_level & AM_LOG_LEVEL_DEBUG) {
        return ANSI_GREEN;
    } else {
        return "";
    }
}

static AM_ATTR_RETURNS_NON_NULL
const char *color_reset(bool color)
{
    if (!color) {
        return "";
    }
    return ANSI_RESET;
}

/****/

static
am_log_writer_fn writer_fallback;

AM_PUBLIC
void am_log_structured_array(
        enum am_log_level_flags log_level,
        const struct am_log_field *fields,
        size_t num_fields)
{
    am_log_writer_fn *writer_func = writer_fallback;
    void *writer_userdata = NULL;
    unsigned depth;

    /* Ensure logging is setup */
    am_call_once(&g_initialized, setup);

    if (!am_contract("amlib", AM_LOG_LEVEL_ERROR, fields != NULL))
        return;
    if (!am_contract("amlib", AM_LOG_LEVEL_WARNING, num_fields > 0))
        return;

    depth = (unsigned)(uintptr_t)am_tss_get(g_log_structured_depth);

    if (depth == 0) {
        am_mutex_lock(&g_messages_lock);
        {
            writer_func = g_log_writer_fn;
            writer_userdata = g_log_writer_userdata;
        }
        am_mutex_unlock(&g_messages_lock);
    }

    assert(writer_func != NULL);
    am_tss_set(g_log_structured_depth, (void *)(uintptr_t)(depth + 1));
    writer_func(log_level, fields, num_fields, writer_userdata);
    am_tss_set(g_log_structured_depth, (void *)(uintptr_t)depth);

    if (log_level & AM_LOG_FLAG_FATAL) {
        log_abort((log_level & AM_LOG_FLAG_RECURSION) ? false : true);
    }
}

AM_PUBLIC
void am_log_structured(const char *log_domain, enum am_log_level_flags log_level, ...)
{
    va_list args;
    char buffer[1024];
    const char *format;
    void *p;
    size_t n_fields;
    struct am_log_field fields[16];

    /* Ensure logging is setup */
    am_call_once(&g_initialized, setup);

    va_start(args, log_level);

    n_fields = 2;
    if (log_domain)
        n_fields++;

    for (p = va_arg(args, char *);
            strcmp(p, "MESSAGE") != 0 && n_fields < 16;
            p = va_arg(args, char *), n_fields++) {
        fields[n_fields].key = p;
        fields[n_fields].value = va_arg(args, void *);
        fields[n_fields].length = -1;
    }

    format = va_arg(args, const char *);
    vsnprintf(buffer, sizeof buffer, format, args);
    buffer[1023] = '\0';

    fields[0].key = "MESSAGE";
    fields[0].value = buffer;
    fields[0].length = -1;
    fields[1].key = "PRIORITY";
    fields[1].value = log_level_to_priority(log_level);
    fields[1].length = -1;
    if (log_domain) {
        fields[2].key = "AM_DOMAIN";
        fields[2].value = log_domain;
        fields[2].length = -1;
    }

    am_log_structured_array(log_level, fields, n_fields);

    va_end(args);
}

AM_PUBLIC
void am_set_writer_func(am_log_writer_fn *fn, void *userdata)
{
    /* Ensure logging is setup */
    am_call_once(&g_initialized, setup);

    assert(fn != NULL);

    am_mutex_lock(&g_messages_lock);
    {
        g_log_writer_fn = fn;
        g_log_writer_userdata = userdata;
    }
    am_mutex_unlock(&g_messages_lock);
}

void am_log_structured_standard(
        const char *log_domain,
        enum am_log_level_flags log_level,
        const char *file, const char *line, const char *func,
        const char *fmt, ...)
{
    struct am_log_field fields[6];
    va_list args;
    char buffer[1024];
    unsigned num_fields = 0;

    /* Ensure logging is setup */
    am_call_once(&g_initialized, setup);

    va_start(args, fmt);
    vsnprintf(buffer, sizeof buffer, fmt, args);
    buffer[1023] = '\0';
    va_end(args);

    fields[num_fields].key    = "PRIORITY";
    fields[num_fields].value  = log_level_to_priority(log_level);
    fields[num_fields].length = -1;
    num_fields++;
    fields[num_fields].key    = "MESSAGE";
    fields[num_fields].value  = buffer;
    fields[num_fields].length = -1;
    num_fields++;
    if (file) {
        fields[num_fields].key    = "CODE_FILE";
        fields[num_fields].value  = file;
        fields[num_fields].length = -1;
        num_fields++;
    }
    if (line) {
        fields[num_fields].key    = "CODE_LINE";
        fields[num_fields].value  = line;
        fields[num_fields].length = -1;
        num_fields++;
    }
    if (func) {
        fields[num_fields].key    = "CODE_FUNC";
        fields[num_fields].value  = func;
        fields[num_fields].length = -1;
        num_fields++;
    }
    if (log_domain) {
        fields[num_fields].key = "AM_DOMAIN";
        fields[num_fields].value = log_domain;
        fields[num_fields].length = -1;
        num_fields++;
    }
    am_log_structured_array(log_level, fields, num_fields);
}

int am_log_writer_default(
        enum am_log_level_flags log_level,
        const struct am_log_field *fields,
        size_t num_fields,
        void *userdata)
{
    size_t i;
    const char *message = NULL;
    const char *domain = NULL;
    const char *progname = am_progname();
    int message_len = 0;
    int domain_len = 0;
    bool color = true;
    char time_buf[128];
    struct timespec ts;
    struct tm *now_tm;

    (void)userdata;

    /* Search for "MESSAGE" and "AM_DOMAIN" fields */
    for (i = 0; (message == NULL || domain == NULL) && i < num_fields; i++) {
        const struct am_log_field *field = &fields[i];
        if (strcmp(field->key, "MESSAGE") == 0) {
            message = field->value;
            message_len = field->length;
        }
        if (strcmp(field->key, "AM_DOMAIN") == 0) {
            domain = field->value;
            domain_len = field->length;
        }
    }

    if (message != NULL && message_len < 0) {
        message_len = strlen(message);
    }
    if (domain != NULL && domain_len < 0) {
        domain_len = strlen(domain);
    }

    /* Print process info */
    fprintf(stderr, "(%s:%d): ", progname ? progname : "process", am_getpid());
    /* Print domain */
    if (domain) {
        fwrite(domain, sizeof(char), domain_len, stderr);
        /* fputs(domain, stderr); */
        fputs("-", stderr);
    }
    /* Print colored log level */
    fprintf(stderr, "%s%s%s: ",
            log_level_to_color(log_level, color),
            log_level_to_string(log_level),
            color_reset(color));
    /* Print timestamp */
    am_gettimeofday(&ts);
    now_tm = localtime(&ts.tv_sec);
    strftime(time_buf, sizeof time_buf, "%H:%M:%S", now_tm);
    fprintf(stderr, "%s%s.%03d%s: ",
            color ? ANSI_LIGHT_BLUE : "",
            time_buf,
            (int)((ts.tv_nsec / 1000) % 1000),
            color_reset(color));
    /* Print message */
    if (message) {
        fwrite(message, sizeof(char), message_len, stderr);
    } else {
        fputs("(NULL) message", stderr);
    }

    fputs("\n\n", stderr);
    fflush(stderr);
    return AM_LOG_WRITER_HANDLED;
}


/* Fallback writer if logging occurs while calling writer function (oops) */
static
int writer_fallback(
        enum am_log_level_flags log_level,
        const struct am_log_field *fields,
        size_t num_fields,
        void *userdata)
{
    size_t i;
    (void)log_level;
    (void)userdata;

    for (i = 0; i < num_fields; i++) {
        const struct am_log_field *field = &fields[i];

        if (strcmp(field->key, "MESSAGE")         == 0 ||
            strcmp(field->key, "MESSAGE_ID")      == 0 ||
            strcmp(field->key, "PRIORITY")        == 0 ||
            strcmp(field->key, "CODE_FILE")       == 0 ||
            strcmp(field->key, "CODE_LINE")       == 0 ||
            strcmp(field->key, "CODE_FUNC")       == 0 ||
            strcmp(field->key, "ERRNO")           == 0 ||
            strcmp(field->key, "SYSLOG_FACILITY") == 0 ||
            strcmp(field->key, "SYSLOG_PID")      == 0 ||
            strcmp(field->key, "AM_DOMAIN")       == 0)
        {
            fputs(field->key, stderr);
            fputs("=", stderr);
            if (field->length < 0) {
                fputs(field->value, stderr);
            } else {
                fwrite(field->value, sizeof(char), field->length, stderr);
            }
            fputs("\n", stderr);
        }
    }

    fprintf(stderr, "_PID=%d", (int)am_getpid());
    return AM_LOG_WRITER_HANDLED;
}

